// Re-exported metadata for functions collected via #[function]
#[derive(Clone, Copy)]
pub struct FnMeta {
    pub name: &'static str,
    pub arity: u8,
    pub addr: *const u8,
    pub mod_path: &'static str,
}

// Safe because addr points to a 'static extern "C" function shim generated by the macro
unsafe impl Sync for FnMeta {}

inventory::collect!(FnMeta);

#[macro_export]
macro_rules! register_functions {
    ($eng:expr, $($name:ident),+ $(,)?) => {{
        let mut res: Result<(), $crate::JitError> = Ok(());
        let wanted: &[&str] = &[ $( stringify!($name) ),+ ];
        for meta in $crate::inventory::iter::<$crate::FnMeta> {
            if wanted.contains(&meta.name) {
                res = res.and_then(|_| unsafe {
                    match meta.arity {
                        0 => $eng.register_nullary(meta.name, std::mem::transmute::<*const u8, $crate::Fn0>(meta.addr)),
                        1 => $eng.register_unary(meta.name, std::mem::transmute::<*const u8, $crate::Fn1>(meta.addr)),
                        2 => $eng.register_binary(meta.name, std::mem::transmute::<*const u8, $crate::Fn2>(meta.addr)),
                        3 => $eng.register_ternary(meta.name, std::mem::transmute::<*const u8, $crate::Fn3>(meta.addr)),
                        _ => Err($crate::JitError::Internal(format!("unsupported arity {} for {}", meta.arity, meta.name))),
                    }
                });
            }
        }
        res
    }};
}
